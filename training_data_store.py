import sqlite3
import os
from typing import List, Optional, Tuple

DATABASE_FILE = "training_data_B.db"

def init_database():
    """Initialize the training data database with the required table"""
    with sqlite3.connect(DATABASE_FILE) as conn:
        cursor = conn.cursor()
        
        # Create training_data table
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS training_data (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                question TEXT NOT NULL UNIQUE,
                answer TEXT NOT NULL,
                uid TEXT NOT NULL UNIQUE,
                generated_model TEXT NOT NULL,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        """)
        
        # Create index for faster lookups
        cursor.execute("CREATE INDEX IF NOT EXISTS idx_uid ON training_data(uid)")
        cursor.execute("CREATE INDEX IF NOT EXISTS idx_question ON training_data(question)")
        cursor.execute("CREATE INDEX IF NOT EXISTS idx_model ON training_data(generated_model)")
        
        conn.commit()
    print(f"Database initialized: {DATABASE_FILE}")

def create_training_data(question: str, answer: str, uid: str, generated_model: str) -> bool:
    """
    Create a new training data entry
    
    Args:
        question: The question text
        answer: The answer text
        uid: Unique identifier for this Q&A pair
        generated_model: The model used to generate this data
    
    Returns:
        bool: True if successful, False if failed (e.g., duplicate question)
    """
    try:
        with sqlite3.connect(DATABASE_FILE) as conn:
            cursor = conn.cursor()
            
            cursor.execute("""
                INSERT INTO training_data (question, answer, uid, generated_model)
                VALUES (?, ?, ?, ?)
            """, (question, answer, uid, generated_model))
            
            conn.commit()
        return True
    
    except sqlite3.IntegrityError:
        # Question already exists
        return False
    except Exception as e:
        print(f"Error creating training data: {e}")
        return False

def get_all_training_data() -> List[Tuple]:
    """Get all training data entries"""
    try:
        with sqlite3.connect(DATABASE_FILE) as conn:
            cursor = conn.cursor()
            
            cursor.execute("""
                SELECT id, question, answer, uid, generated_model, created_at
                FROM training_data
                ORDER BY created_at DESC
            """)
            
            results = cursor.fetchall()
        return results
    
    except Exception as e:
        print(f"Error getting training data: {e}")
        return []

def get_training_data_by_model(model_name: str) -> List[Tuple]:
    """Get training data generated by a specific model"""
    try:
        with sqlite3.connect(DATABASE_FILE) as conn:
            cursor = conn.cursor()
            
            cursor.execute("""
                SELECT id, question, answer, uid, generated_model, created_at
                FROM training_data
                WHERE generated_model = ?
                ORDER BY created_at DESC
            """, (model_name,))
            
            results = cursor.fetchall()
        return results
    
    except Exception as e:
        print(f"Error getting training data by model: {e}")
        return []

def get_training_data_by_uid(uid: str) -> Optional[Tuple]:
    """Get a specific training data entry by UID"""
    try:
        with sqlite3.connect(DATABASE_FILE) as conn:
            cursor = conn.cursor()
            
            cursor.execute("""
                SELECT id, question, answer, uid, generated_model, created_at
                FROM training_data
                WHERE uid = ?
            """, (uid,))
            
            result = cursor.fetchone()
        return result
    
    except Exception as e:
        print(f"Error getting training data by UID: {e}")
        return None

def get_training_data_by_article_uuid(article_uid: str) -> List[Tuple]:
    """Get training data generated from a specific article (for backward compatibility)"""
    # This function is kept for compatibility with the data generator
    # Since we're not tracking article UIDs anymore, return empty list
    return []

def delete_training_data(uid: str) -> bool:
    """Delete a training data entry by UID"""
    try:
        with sqlite3.connect(DATABASE_FILE) as conn:
            cursor = conn.cursor()
            
            cursor.execute("DELETE FROM training_data WHERE uid = ?", (uid,))
            
            deleted = cursor.rowcount > 0
            conn.commit()
        return deleted
    
    except Exception as e:
        print(f"Error deleting training data: {e}")
        return False

def get_training_data_count() -> int:
    """Get total count of training data entries"""
    try:
        with sqlite3.connect(DATABASE_FILE) as conn:
            cursor = conn.cursor()
            
            cursor.execute("SELECT COUNT(*) FROM training_data")
            count = cursor.fetchone()[0]
        return count
    
    except Exception as e:
        print(f"Error getting training data count: {e}")
        return 0

def get_models_stats() -> List[Tuple[str, int]]:
    """Get statistics about training data by model"""
    try:
        with sqlite3.connect(DATABASE_FILE) as conn:
            cursor = conn.cursor()
            
            cursor.execute("""
                SELECT generated_model, COUNT(*)
                FROM training_data
                GROUP BY generated_model
                ORDER BY COUNT(*) DESC
            """)
            
            results = cursor.fetchall()
        return results
    
    except Exception as e:
        print(f"Error getting model stats: {e}")
        return []

# Initialize database on import
if __name__ == "__main__":
    init_database()
else:
    # Auto-initialize when imported
    if not os.path.exists(DATABASE_FILE):
        init_database()